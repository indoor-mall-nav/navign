"""
gRPC client for beacon registration with the orchestrator.

Communicates with the OrchestratorSync service to register beacons
and report their status.
"""

import time
from typing import List, Optional

import grpc

# Import generated protobuf code (will be generated by generate_proto.sh)
try:
    from proto import sync_pb2, sync_pb2_grpc
except ImportError as e:
    # Try alternative import (for editable installs)
    try:
        import sys
        from pathlib import Path

        # Add proto directory to path
        proto_dir = Path(__file__).parent.parent / "proto"
        if proto_dir.exists():
            sys.path.insert(0, str(proto_dir))
            import sync_pb2  # type: ignore
            import sync_pb2_grpc  # type: ignore
        else:
            raise ImportError(
                "Protobuf code not generated. Run: ./generate_proto.sh"
            ) from e
    except ImportError:
        raise ImportError(
            "Protobuf code not generated. Run: ./generate_proto.sh"
        ) from e


class BeaconRegistrationClient:
    """Client for registering beacons with the orchestrator."""

    def __init__(self, orchestrator_addr: str):
        """
        Initialize the beacon registration client.

        Args:
            orchestrator_addr: Address of orchestrator (e.g., "localhost:50051")
        """
        self.orchestrator_addr = orchestrator_addr
        self.channel: Optional[grpc.Channel] = None
        self.stub: Optional[sync_pb2_grpc.OrchestratorSyncStub] = None

    def connect(self) -> None:
        """Establish connection to the orchestrator gRPC server."""
        print(f"   Connecting to orchestrator at {self.orchestrator_addr}...")
        self.channel = grpc.insecure_channel(self.orchestrator_addr)
        self.stub = sync_pb2_grpc.OrchestratorSyncStub(self.channel)
        print("   Connected successfully!")

    def close(self) -> None:
        """Close the connection to the orchestrator."""
        if self.channel:
            self.channel.close()

    def register_beacon(
        self,
        entity_id: str,
        device_id: str,
        device_type: str,
        public_key_pem: str,
        firmware_version: str,
        hardware_revision: str,
        capabilities: List[str],
        area_id: Optional[str] = None,
    ) -> dict:
        """
        Register a beacon with the orchestrator.

        Args:
            entity_id: Entity/building identifier
            device_id: Device ID (24-character hex)
            device_type: Device type (Merchant, Pathway, Connection, Turnstile)
            public_key_pem: PEM-encoded P-256 public key
            firmware_version: Firmware version (e.g., "0.1.0")
            hardware_revision: Hardware revision (e.g., "v1.0")
            capabilities: List of capabilities (e.g., ["UnlockGate"])
            area_id: Optional area ID where beacon is located

        Returns:
            Dictionary with registration response data

        Raises:
            grpc.RpcError: If registration fails
        """
        if not self.stub:
            raise RuntimeError("Client not connected. Call connect() first.")

        # Prepare location if area_id provided
        location = None
        if area_id:
            location = sync_pb2.BeaconLocation(
                area_id=area_id,
                coordinates=sync_pb2.Location(x=0.0, y=0.0, z=0.0, floor=""),
            )

        # Create registration request
        request = sync_pb2.BeaconRegistrationRequest(
            entity_id=entity_id,
            device_id=device_id,
            device_type=device_type,
            capabilities=capabilities,
            public_key=public_key_pem,
            firmware_version=firmware_version,
            hardware_revision=hardware_revision,
            location=location,
            registered_at=sync_pb2.Timestamp(seconds=int(time.time())),
        )

        print("   Sending beacon registration request...")

        # Send request
        response = self.stub.RegisterBeacon(request)

        # Check if approved
        if not response.approved:
            raise RuntimeError("Beacon registration was not approved by orchestrator")

        print("   ✅ Beacon approved by orchestrator")
        print(f"      Beacon ID: {response.beacon_id}")
        print(f"      Entity ID: {response.entity_id}")
        print(f"      Sync interval: {response.sync_interval_seconds} seconds")

        if response.firmware_update_available:
            print("      ⚠️  Firmware update available")
            if response.latest_firmware:
                print(f"         Latest version: {response.latest_firmware.version}")

        return {
            "beacon_id": response.beacon_id,
            "entity_id": response.entity_id,
            "approved": response.approved,
            "sync_interval_seconds": response.sync_interval_seconds,
            "firmware_update_available": response.firmware_update_available,
        }
